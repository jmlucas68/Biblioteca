<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Tabla precargada en memoria (Opción 1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --gap: 8px;
      --border: 1px solid #ddd;
      --bg: #f8f9fa;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .toolbar { display: flex; flex-wrap: wrap; gap: var(--gap); align-items: center; margin-bottom: 12px; }
    .toolbar input[type="search"] { flex: 1 1 280px; padding: 8px 10px; }
    .toolbar button { padding: 8px 12px; cursor: pointer; }
    .status { font-size: 12px; color: #666; }
    table { width: 100%; border-collapse: collapse; background: white; }
    thead th { position: sticky; top: 0; background: var(--bg); border-bottom: var(--border); text-align: left; padding: 8px; cursor: pointer; }
    tbody td { border-top: var(--border); padding: 8px; }
    .right { text-align: right; }
    .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid #ccc; border-top-color: #333; border-radius: 50%; animation: spin 0.8s linear infinite; vertical-align: text-bottom; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .pager { display: flex; gap: var(--gap); align-items: center; margin-top: 10px; }
    .pager button { padding: 6px 10px; }
    .muted { opacity: 0.66; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <h1>Listado</h1>

  <div class="toolbar">
    <input id="q" type="search" placeholder="Buscar..." autocomplete="off" />
    <button id="refreshBtn" title="Recargar manualmente desde el servidor">Refrescar</button>
    <span id="loading" class="status hidden"><span class="spinner"></span> Cargando...</span>
    <span id="info" class="status muted"></span>
  </div>

  <div style="overflow:auto; max-height: 70vh; border: 1px solid #eee;">
    <table id="grid">
      <thead>
        <!-- Ajustar nombres de columnas y data-key a los campos reales -->
        <tr>
          <th data-key="id" data-type="number">ID</th>
          <th data-key="nombre" data-type="string">Nombre</th>
          <th data-key="categoria" data-type="string">Categoría</th>
          <th data-key="precio" class="right" data-type="number">Precio</th>
          <th data-key="fecha" data-type="date">Fecha</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="pager">
    <button id="prev">Anterior</button>
    <span id="pageInfo" class="muted"></span>
    <button id="next">Siguiente</button>
    <select id="pageSize">
      <option value="10">10 filas</option>
      <option value="25">25 filas</option>
      <option value="50">50 filas</option>
      <option value="100">100 filas</option>
    </select>
  </div>

  <script>
    // ===================== Ajustes =====================
    // Reemplazar por el endpoint real que devuelve TODA la tabla en JSON
    const ENDPOINT = "/api/tabla-completa"; // ej.: GET devuelve [{id, nombre, categoria, precio, fecha}, ...]
    // Caché opcional en localStorage para no re-pedir en recargas de página
    const CACHE_KEY = "tabla_completa_cache_v1";
    // Establecer a null si no se desea TTL; en milisegundos (ej. 12h)
    const CACHE_TTL = 12 * 60 * 60 * 1000;

    // ===================== Estado =====================
    let ALL_ROWS = [];      // toda la tabla en memoria (opción 1)
    let VIEW_ROWS = [];     // filas tras filtro/orden
    let sortKey = null;
    let sortDir = 1;        // 1 asc, -1 desc
    let page = 1;
    let pageSize = 10;

    // ===================== Utilidades =====================
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    function escapeHTML(v) {
      return String(v ?? "").replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
    }
    function parseDate(v) {
      // Asegurar formato de fecha parseable o personalizar según backend (YYYY-MM-DD, ISO, etc.)
      const d = new Date(v);
      return isNaN(d) ? null : d;
    }
    function formatNumber(n) {
      const x = Number(n);
      return Number.isFinite(x) ? x.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : "";
    }

    function setLoading(on) { $("#loading").classList.toggle("hidden", !on); }
    function setInfo(txt) { $("#info").textContent = txt || ""; }

    // ===================== Carga inicial única =====================
    async function fetchAllFromServer() {
      setLoading(true);
      try {
        const res = await fetch(ENDPOINT, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        // Guardar en caché opcional con sello de tiempo
        try {
          localStorage.setItem(CACHE_KEY, JSON.stringify({ t: Date.now(), data }));
        } catch(e) { /* almacenamiento lleno o bloqueado */ }
        return data;
      } finally {
        setLoading(false);
      }
    }

    function loadFromCache() {
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return null;
        const { t, data } = JSON.parse(raw);
        if (CACHE_TTL != null && t && (Date.now() - t) > CACHE_TTL) {
          localStorage.removeItem(CACHE_KEY);
          return null;
        }
        return data;
      } catch(e) {
        return null;
      }
    }

    async function loadAllOnce() {
      // 1) Intentar caché (misma sesión o dentro del TTL)
      const cached = loadFromCache();
      if (cached && Array.isArray(cached)) {
        ALL_ROWS = cached;
        return;
      }
      // 2) Obtener del servidor solo una vez
      ALL_ROWS = await fetchAllFromServer();
    }

    // ===================== Render =====================
    function applyFilterSort() {
      const q = $("#q").value.trim().toLowerCase();
      const keys = $$("#grid thead th").map(th => th.dataset.key).filter(Boolean);

      // Filtrado simple en cliente
      VIEW_ROWS = ALL_ROWS.filter(row => {
        if (!q) return true;
        return keys.some(k => String(row[k] ?? "").toLowerCase().includes(q));
      });

      // Ordenación en cliente
      if (sortKey) {
        const type = ($(`#grid thead th[data-key="${sortKey}"]`)?.dataset.type) || "string";
        VIEW_ROWS.sort((a, b) => {
          let av = a[sortKey], bv = b[sortKey];
          if (type === "number") {
            av = Number(av); bv = Number(bv);
            if (!Number.isFinite(av)) av = -Infinity;
            if (!Number.isFinite(bv)) bv = -Infinity;
          } else if (type === "date") {
            av = parseDate(av)?.getTime() ?? 0;
            bv = parseDate(bv)?.getTime() ?? 0;
          } else {
            av = String(av ?? "").toLowerCase();
            bv = String(bv ?? "").toLowerCase();
          }
          return av < bv ? -1 * sortDir : av > bv ? 1 * sortDir : 0;
        });
      }
    }

    function renderTable() {
      applyFilterSort();

      // Paginación en cliente
      const total = VIEW_ROWS.length;
      const totalPages = Math.max(1, Math.ceil(total / pageSize));
      if (page > totalPages) page = totalPages;

      const start = (page - 1) * pageSize;
      const rows = VIEW_ROWS.slice(start, start + pageSize);

      const tbody = $("#grid tbody");
      const cols = $$("#grid thead th").map(th => ({ key: th.dataset.key, type: th.dataset.type }));
      tbody.innerHTML = rows.map(row => {
        return `<tr>
          <td>${escapeHTML(row.id)}</td>
          <td>${escapeHTML(row.nombre)}</td>
          <td>${escapeHTML(row.categoria)}</td>
          <td class="right">${formatNumber(row.precio)}</td>
          <td>${escapeHTML(row.fecha)}</td>
        </tr>`;
      }).join("");

      $("#pageInfo").textContent = `Página ${page} de ${totalPages} · ${total} filas`;
      setInfo(`Filas en memoria: ${ALL_ROWS.length}`);
    }

    // ===================== Interacciones =====================
    function attachEvents() {
      // Buscar
      $("#q").addEventListener("input", () => { page = 1; renderTable(); });

      // Ordenar al pulsar encabezados
      $$("#grid thead th").forEach(th => {
        const key = th.dataset.key;
        if (!key) return;
        th.addEventListener("click", () => {
          if (sortKey === key) {
            sortDir = -1 * sortDir; // alternar asc/desc
          } else {
            sortKey = key;
            sortDir = 1;
          }
          renderTable();
        });
      });

      // Paginación
      $("#prev").addEventListener("click", () => { if (page > 1) { page--; renderTable(); } });
      $("#next").addEventListener("click", () => { page++; renderTable(); });
      $("#pageSize").addEventListener("change", (e) => {
        pageSize = Number(e.target.value) || 10;
        page = 1;
        renderTable();
      });

      // Refresco manual (única vía para reconsultar servidor)
      $("#refreshBtn").addEventListener("click", async () => {
        // Si se desea no tocar caché, comentar la línea de removeItem
        try { localStorage.removeItem(CACHE_KEY); } catch(e) {}
        await loadAllOnce();
        page = 1;
        renderTable();
      });
    }

    // ===================== Inicio =====================
    (async function init() {
      attachEvents();
      await loadAllOnce(); // carga única de toda la tabla en memoria
      renderTable();
    })();
  </script>
</body>
</html>
